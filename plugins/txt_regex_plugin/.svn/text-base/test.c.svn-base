/***************************************************************************
*
*   File    : test.c
*   Purpose : Test the regex functionalities
*
*   Author: David Ruano
*
*
*   Date    : October  25, 2010
*
*****************************************************************************
*   LICENSING
*****************************************************************************
*
* WB4Spam: An ANSI C is an open source, highly extensible, high performance and
* multithread spam filtering platform. It takes concepts from SpamAssassin project
* improving distinct issues.
*
* Copyright (C) 2010, by Sing Research Group (http://sing.ei.uvigo.es)
*
* This file is part of WireBrush for Spam project.
*
* Wirebrush for Spam is free software; you can redistribute it and/or
* modify it under the terms of the GNU Lesser General Public License as
* published by the Free Software Foundation; either version 3 of the
* License, or (at your option) any later version.
*
* Wirebrush for Spam is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser
* General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*
***********************************************************************/

#define __TEST
#include "regex_util.h"
#include <stdio.h>
#include "eml_structure_parser.h"


int main(int argc, char *argv[]){
    struct regex_data *data;
    data=malloc(sizeof(struct regex_data));

    char *target_content;
    regex_t *regex;
    char *header, *expr, *tmp;
    char *email;
    ae_load_eml_to_memory(argv[1],&email);



    expr="[lL][eE][vV][iI?1!][tT][rR][aA]";
    printf("1\n");

    if (data!=NULL) data->regex_cache = hashmap_new();

    if(data==NULL || hashmap_get(data->regex_cache,expr,(any_t *)&regex)==MAP_MISSING){
        regex=rgx_compile(expr); //Compile the expression
        if (regex==NULL) {
            wblprintf(LOG_WARNING,"REGEX_PLUGIN(eval_header)","Incorrect regular expression %s\n", expr);
            return 0;
        }

        if (data!=NULL) {
            tmp=malloc(sizeof(char)*(strlen(expr)+1)); //Make a copy of the uncompiled regex for cache
            strcpy(tmp,expr);
            hashmap_put(data->regex_cache,tmp,(any_t)regex); //store the compiled regex in cache
        }
    }
    printf("2\n");
    //Return the content to test in the raw entry generated by eml_structure_parser parser
    if (hashmap_get(parsed_mail,"body",(any_t *)&target_content)!=MAP_OK){
    	wblprintf(LOG_WARNING, "REGEX_PLUGIN (eval_header)","Unable to found raw entry on contents.\n");
    	return 0;
    }

    printf("3\n");

    free_mail(parsed_mail);

    free(email);
    //Free all compiled regex
    hashmap_iterate_elements(data->regex_cache,&free_regex,NULL);


    return rgx_match(regex,target_content);
    //free the hashmaps
    hashmap_free(data->regex_cache);

    free(data);
	
    return 0;
}
